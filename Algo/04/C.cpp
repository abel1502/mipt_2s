/*

Крис Юрьевич Каменев на вокзале решил сыграть в "Трехкарточный Монти", хотя его мать запретила ему это делать. В этой игре участвуют три карты, выставленные в ряд слева направо. Изначально карта с валетом, которую нужно угадать, находится под стоящей посередине чашкой.

Затем, за один ход карточный мошенник меняет местами карту посередине с одной из двух других карт случайным образом (он выберет каждую с одинаковой вероятностью), так что выбранная карта становится посередине. Игра длится n ходов, и в каждом из них мошенник независимо выбирает карту для обмена со средней на каждом ходу.

После n-го хода мошенник просит Криса указать на карту с валетом, и он указывает на стоящую посередине карту, но Крис отвлекся во время игры и не уверен, находится ли там карта или нет. Поэтому он просит вас сообщить ему вероятность того, что карта с валетом действительно посередине.

Число ходов n может быть очень большим, поэтому Крис не сообщил вам его. Вместо этого он дал вам массив a1,a2,...,ak, такой, что

n=\N{N-ARY PRODUCT}i=1kai,
другими словами, n равно произведению чисел данного массива.
Из-за проблем с точностью Крис просит вас сообщить ответ в виде несократимой дроби. Другими словами, найдите ответ в виде p/q, причем gcd(p,q)=1, где gcd — наибольший общий делитель. Так как p и q могут быть очень большими, достаточно вывести остаток от деления каждого из них на 109+7.

Заметьте, что мы хотим, чтобы наибольший общий делитель p и q был равен 1, а не наибольший общий делитель их остатков от деления на 109+7.

Входные данные
В первой строке содержится единственное целое число k (1\N{LESS-THAN OR EQUAL TO}k\N{LESS-THAN OR EQUAL TO}105) — количество элементов в массиве, данном Крисом.

Во второй строке содержатся k целых чисел a1,a2,…,ak (1\N{LESS-THAN OR EQUAL TO}ai\N{LESS-THAN OR EQUAL TO}1018) — элементы массива.

Выходные данные
В единственной строке выведите строку вида x/y, где x — остаток от деления p на 109+7, а y — остаток от деления q на 109+7.

Примеры
входные данные
1
2
выходные данные
1/2
входные данные
3
1 1 1
выходные данные
0/1

*/


#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <string>
#include <algorithm>
#include <vector>
#include <numeric>


unsigned long long pow(unsigned long long base, unsigned long long power, unsigned long long mod) {
    // I finally managed to implement this iteratively

    unsigned long long result = 1;

    while (power) {
        if (!(power & 1)) {
            base = (base * base) % mod;
            power >>= 1;
        } else {
            result = (result * base) % mod;
            --power;
        }
    }

    return result;
}


int main() {
    const unsigned long long MOD = 1000000007;

    unsigned k = 0;
    int res = scanf("%u", &k);
    assert(res == 1);

    std::vector<unsigned long long> a(k, 0);
    for (unsigned i = 0; i < k; ++i) {
        res = scanf("%llu", &a[i]);
        assert(res == 1);
    }

    unsigned long long p = MOD - 1;
    unsigned long long q = 2;

    for (unsigned i = 0; i < k; ++i) {
        if (!(a[i] & 1)) p = 1;
        q = pow(q, a[i], MOD);
    }

    q = (q * pow(2, MOD - 2, MOD)) % MOD;
    p = (((p + q) % MOD) * pow(3, MOD - 2, MOD)) % MOD;

    printf("%llu/%llu\n", p, q);

    return 0;
}

/*

The formula is: p=(2**(n-1)+(-1)**n)/3  (mod MOD), q=2**(n-1)  (mod MOD)
(And it's not me who deduced it, there was a semi-collective discussion)

Then:
2**(n-1)=(((2**a[1])**a[2])**...)*2**(MOD-2), (...)/3=(...)*3**(MOD-2)  (mod MOD)

*/

