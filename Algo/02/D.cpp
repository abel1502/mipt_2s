/*

Компания Gnusmas разработала новую модель мобильного телефона. Основное достоинство этой модели — ударопрочность: её корпус сделан из особого сплава, и телефон должен выдерживать падение с большой высоты.

Компания Gnusmas арендовала n-этажное здание и наняла экспертов, чтобы те при помощи серии экспериментов выяснили, с какой высоты бросать телефон можно, а с какой — нельзя. Один эксперимент заключается в том, чтобы бросить телефон с какого-то этажа и посмотреть, сломается он от этого или нет. Известно, что любой телефон этой модели ломается, если его сбросить с x-го этажа или выше, где x — некоторое целое число от 1 до n, включительно, и не ломается, если сбросить его с более низкого этажа. Задача экспертов заключается в том, чтобы узнать число x и передать его рекламному отделу компании.

Задача осложняется тем, что экспертам предоставлено всего k образцов новой модели телефона. Каждый телефон можно бросать сколько угодно раз, пока он не сломается; после этого использовать его для экспериментов больше не удастся.

Подумав, эксперты решили действовать так, чтобы минимизировать максимально возможное количество экспериментов, которое может потребоваться произвести. Чему равно это количество?

Входные данные
В первой строке входного файла записаны через пробел два целых числа n и k — количество этажей в здании и количество предоставленных телефонов (1\N{LESS-THAN OR EQUAL TO}n\N{LESS-THAN OR EQUAL TO}100000, 0\N{LESS-THAN OR EQUAL TO}k<n).

Выходные данные
В выходной файл выведите единственное число — минимальное количество экспериментов, которое потребуется совершить, чтобы узнать число x и использовать не более k телефонов. Если решить задачу невозможно, выведите вместо этого \N{MINUS SIGN}1.

Примеры
входные данные
4 2
выходные данные
2
входные данные
4 1
выходные данные
3
Примечание
В первом примере сначала следует бросить телефон со второго этажа. Если он сломается, то второй бросок следует сделать с первого этажа. В случае поломки станет известно, что x=1. Иначе мы узнаем, что x=2.

Если же при броске со второго этажа телефон не сломался, бросим телефон с третьего этажа. При поломке будет ясно, что x=3. Иначе из условия 1\N{LESS-THAN OR EQUAL TO}x\N{LESS-THAN OR EQUAL TO}4 следует, что x=4.

Всего будет сделано два эксперимента. В них будет использовано не более чем два телефона.

Во втором примере следует сначала бросить единственный данный нам телефон с первого этажа, если он не сломается, то со второго, а если опять не сломается, то с третьего. При первой же поломке мы узнаем точное значение x. Если после трёх бросков телефон так и не сломался, то x=4.

*/


#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <algorithm>
#include <vector>


int main() {
    unsigned n = 0;
    unsigned k = 0;

    int res = scanf("%u %u", &n, &k);
    assert(res == 2);

    if (n == 1) {
        printf("0\n");
        return 0;
    }

    if (k == 0) {
        printf("%d\n", -1);
        return 0;
    }

    std::vector<unsigned> dp(n + 1, 0);
    std::vector<unsigned> dp2(n + 1, 0);

    dp[0] = 2;

    for (unsigned i = 1; i <= n; ++i)
        dp[i] = i + 1;

    for (unsigned i = 0; i < k - 1; ++i) {
        for (unsigned j = i; j <= n; ++j) {
            dp2[j + 1] = dp2[j] + dp[j];

            if (dp2[j + 1] > n - 1)
                break;
        }

        dp.swap(dp2);
    }

    for (unsigned i = 0; i < n; ++i) {
        if (dp[i + 1] >= n && dp[i] <= n) {
            printf("%u\n", i + 1);

            return 0;
        }
    }

    printf("-1\n");

    return 0;
}

/*

dp[i][j] - how many floors can be tested with i phones in up to j experiments
This time I optimized it to just two rows

*/
